"use strict";(self.webpackChunkcocossim_docs=self.webpackChunkcocossim_docs||[]).push([[951],{742:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/architecture","title":"Architecture Overview","description":"COCOSSim is designed as a modular, cycle-accurate simulator for neural network accelerators with systolic array architectures.","source":"@site/docs/guides/architecture.md","sourceDirName":"guides","slug":"/guides/architecture","permalink":"/cocossim-docs/docs/guides/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/mc186/cocossim/tree/main/docs/guides/architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Basic Examples","permalink":"/cocossim-docs/docs/examples/basic"},"next":{"title":"Systolic Arrays Deep Dive","permalink":"/cocossim-docs/docs/guides/systolic-arrays"}}');var r=s(4848),l=s(8453);const t={},c="Architecture Overview",o={},d=[{value:"System Architecture",id:"system-architecture",level:2},{value:"Core Components",id:"core-components",level:2},{value:"1. Frontend System",id:"1-frontend-system",level:3},{value:"2. Job Scheduling System",id:"2-job-scheduling-system",level:3},{value:"3. Processing Units",id:"3-processing-units",level:3},{value:"Systolic Arrays",id:"systolic-arrays",level:4},{value:"Vector Units",id:"vector-units",level:4},{value:"4. Memory Subsystem",id:"4-memory-subsystem",level:3},{value:"5. State Management",id:"5-state-management",level:3},{value:"Data Flow",id:"data-flow",level:2},{value:"1. Initialization Phase",id:"1-initialization-phase",level:3},{value:"2. Execution Phase",id:"2-execution-phase",level:3},{value:"3. Multi-Core Execution",id:"3-multi-core-execution",level:3},{value:"Key Design Decisions",id:"key-design-decisions",level:2},{value:"Parallel Execution Strategy",id:"parallel-execution-strategy",level:3},{value:"Memory Model Integration",id:"memory-model-integration",level:3},{value:"Modular Design",id:"modular-design",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Simulation Speed",id:"simulation-speed",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Accuracy vs Speed",id:"accuracy-vs-speed",level:3},{value:"Extension Points",id:"extension-points",level:2},{value:"Adding New Layer Types",id:"adding-new-layer-types",level:3},{value:"Adding New Processing Units",id:"adding-new-processing-units",level:3},{value:"Custom Memory Models",id:"custom-memory-models",level:3},{value:"Next Steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"architecture-overview",children:"Architecture Overview"})}),"\n",(0,r.jsxs)(n.p,{children:["COCOSSim is designed as a modular, cycle-accurate simulator for neural network accelerators with systolic array architectures.\nCOCOSSim uses ",(0,r.jsx)(n.strong,{children:"state machine models"})," at its core to simulate compute units with cycle-accurate precision. Each processing unit (systolic arrays and vector units) is implemented as a finite state machine that interacts with the job scheduler and memory system through well-defined interfaces."]}),"\n",(0,r.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"COCOSSim Architecture",src:s(8149).A+"",width:"1924",height:"758"})}),"\n",(0,r.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsx)(n.h3,{id:"1-frontend-system",children:"1. Frontend System"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Translate high-level neural network descriptions into executable jobs"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Components"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Layer Parser"}),": Converts layer specifications into job graphs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Job Creation"}),": Handles tensor parallelism and buffer constraints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dependency Management"}),": Manages inter-layer data dependencies"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Files"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/frontends/standard/StandardLayers.cc"})," - Layer implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/frontends/standard/StandardParser.cc"})," - Configuration parsing"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-job-scheduling-system",children:"2. Job Scheduling System"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Coordinate execution across multiple processing units"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task-Based Parallelism"}),": Independent job queues per task thread"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Core Assignment"}),": Jobs assigned to specific cores for true parallelism"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dependency Resolution"}),": Automatic handling of data dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-Period Execution"}),": Support for streaming workloads"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Files"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/Arch.cc"})," - Main simulation loop and job scheduling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/Job.cc"})," - Job creation and dependency tracking"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-processing-units",children:"3. Processing Units"}),"\n",(0,r.jsx)(n.h4,{id:"systolic-arrays",children:"Systolic Arrays"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Matrix multiplication and convolution operations"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Execution Modes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Weight Stationary (WS)"}),": Weights stay in place, activations flow"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output Stationary (OS)"}),": Partial sums accumulate in place"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"State Machine"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"WS Mode: prefetch \u2192 read \u2192 shift \u2192 write \u2192 (next tile)\nOS Mode: read \u2192 shift \u2192 write \u2192 (next tile)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Configurable array sizes (64x64, 128x128, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Automatic tiling for large matrices"}),"\n",(0,r.jsx)(n.li,{children:"Buffer constraint handling"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"vector-units",children:"Vector Units"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Element-wise operations, activations, normalization"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Phases"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"REDUCE"}),": Reductions along dimensions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BROADCAST"}),": Element-wise operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-phase"}),": Complex operations like LayerNorm"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Files"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/units/standard/SysArray.cc"})," - Systolic array implementation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/units/standard/VectorUnit.cc"})," - Vector unit implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-memory-subsystem",children:"4. Memory Subsystem"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Realistic memory modeling with timing accuracy"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Integration"}),": Uses DRAMSim3 for cycle-accurate memory simulation"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Priority-based Transactions"}),": Memory operations with different priorities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Callback System"}),": Completion notifications for processing units"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multiple Memory Types"}),": HBM, DDR4, DDR5 support"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Banking/Channel Models"}),": Realistic memory hierarchy"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Files"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/memory.cc"})," - Memory transaction management"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dramsim3/"})," - Memory simulator submodule"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"5-state-management",children:"5. State Management"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Coordinate processing unit states and memory operations"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Responsibilities"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Queue Management"}),": Read/write transaction queuing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stage Processing"}),": Cycle-based state transitions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Idle Detection"}),": Power and utilization tracking"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"VCD Generation"}),": Waveform output for debugging"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Files"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/State.cc"})," - Base state machine implementation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"include/State.h"})," - State interface and VCD macros"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"data-flow",children:"Data Flow"}),"\n",(0,r.jsx)(n.h3,{id:"1-initialization-phase",children:"1. Initialization Phase"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Layer File \u2192 Parser \u2192 Job Graph \u2192 Task Assignment \u2192 Core Allocation\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-execution-phase",children:"2. Execution Phase"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Job Queue \u2192 Scheduler \u2192 Processing Unit \u2192 Memory System \u2192 Completion\n     \u2191                                                        \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Dependencies \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-multi-core-execution",children:"3. Multi-Core Execution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Core 0: [Job Queue] \u2192 [Systolic Array] \u2192 [Memory]\nCore 1: [Job Queue] \u2192 [Systolic Array] \u2192 [Memory]  \nCore 2: [Job Queue] \u2192 [Vector Unit]   \u2192 [Memory]\nCore 3: [Job Queue] \u2192 [Vector Unit]   \u2192 [Memory]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-design-decisions",children:"Key Design Decisions"}),"\n",(0,r.jsx)(n.h3,{id:"parallel-execution-strategy",children:"Parallel Execution Strategy"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Core-Specific Job Queues"}),": Each core maintains independent job queues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Per-Core Task Counters"}),": Sequential task IDs per core for dependency tracking"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Global Synchronization"}),": Cores operate independently unless data dependent"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"memory-model-integration",children:"Memory Model Integration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transaction-Based Interface"}),": All memory operations go through DRAMSim3"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Priority System"}),": Different operation types have configurable priorities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous Callbacks"}),": Processing units notified when memory operations complete"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"modular-design",children:"Modular Design"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Frontend Abstraction"}),": Easy to add new layer types and architectures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unit Pluggability"}),": Processing units implement common interfaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration Driven"}),": Architecture parameters specified in config files"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"simulation-speed",children:"Simulation Speed"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event-Driven"}),": Only processes active components each cycle"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient Memory Management"}),": Minimizes allocation/deallocation overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parallel Build Support"}),": Multi-threaded compilation"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Job Pooling"}),": Reuses job objects when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selective VCD"}),": VCD generation only when enabled"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configurable Buffers"}),": Memory usage scales with architecture size"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"accuracy-vs-speed",children:"Accuracy vs Speed"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cycle-Accurate Core"}),": Precise timing for processing units"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configurable Memory Detail"}),": Balance between accuracy and simulation speed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Statistical Sampling"}),": Optional sampling for very long workloads"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"extension-points",children:"Extension Points"}),"\n",(0,r.jsx)(n.h3,{id:"adding-new-layer-types",children:"Adding New Layer Types"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Implement layer logic in ",(0,r.jsx)(n.code,{children:"StandardLayers.cc"})]}),"\n",(0,r.jsx)(n.li,{children:"Add parser support in layer configuration"}),"\n",(0,r.jsx)(n.li,{children:"Define job creation and dependency rules"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"adding-new-processing-units",children:"Adding New Processing Units"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Inherit from ",(0,r.jsx)(n.code,{children:"State"})," base class"]}),"\n",(0,r.jsxs)(n.li,{children:["Implement state machine in ",(0,r.jsx)(n.code,{children:"increment()"})," method"]}),"\n",(0,r.jsx)(n.li,{children:"Register unit type in architecture configuration"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"custom-memory-models",children:"Custom Memory Models"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Modify memory transaction interface"}),"\n",(0,r.jsx)(n.li,{children:"Integrate alternative memory simulators"}),"\n",(0,r.jsx)(n.li,{children:"Adjust callback mechanisms as needed"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/cocossim-docs/docs/guides/systolic-arrays",children:"Systolic Arrays Deep Dive"})," - Detailed WS/OS mode explanation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/cocossim-docs/docs/guides/basic-usage",children:"Basic Usage Guide"})," - Getting started with simulations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/cocossim-docs/docs/api/core-classes",children:"Core Classes API"})," - Programming interface details"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8149:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/cocossim_model-ca59db50d241fa0e3b02ffcdf7004270.png"},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var i=s(6540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);