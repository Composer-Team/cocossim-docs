"use strict";(self.webpackChunkcocossim_docs=self.webpackChunkcocossim_docs||[]).push([[248],{708:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"api/core-classes","title":"Core Classes API Reference","description":"This document describes the core classes that form the backbone of COCOSSim.","source":"@site/docs/api/core-classes.md","sourceDirName":"api","slug":"/api/core-classes","permalink":"/cocossim-docs/docs/api/core-classes","draft":false,"unlisted":false,"editUrl":"https://github.com/mc186/cocossim/tree/main/docs/api/core-classes.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Systolic Arrays Deep Dive","permalink":"/cocossim-docs/docs/guides/systolic-arrays"}}');var t=i(4848),r=i(8453);const c={},l="Core Classes API Reference",d={},o=[{value:"Job Class",id:"job-class",level:2},{value:"Overview",id:"overview",level:3},{value:"Declaration",id:"declaration",level:3},{value:"Key Methods",id:"key-methods",level:3},{value:"<code>get_type() -&gt; int</code>",id:"get_type---int",level:4},{value:"<code>get_job_dims_string() -&gt; string</code>",id:"get_job_dims_string---string",level:4},{value:"<code>printDetails()</code>",id:"printdetails",level:4},{value:"Key Fields",id:"key-fields",level:3},{value:"Derived Classes",id:"derived-classes",level:3},{value:"SysArrayJob",id:"sysarrayjob",level:4},{value:"VecUnitJob",id:"vecunitjob",level:4},{value:"State Class",id:"state-class",level:2},{value:"Overview",id:"overview-1",level:3},{value:"Declaration",id:"declaration-1",level:3},{value:"Key Methods",id:"key-methods-1",level:3},{value:"<code>increment() -&gt; bool</code>",id:"increment---bool",level:4},{value:"<code>init()</code>",id:"init",level:4},{value:"Protected Methods",id:"protected-methods",level:3},{value:"<code>enqueue_reads()</code>",id:"enqueue_reads",level:4},{value:"<code>enqueue_writes()</code>",id:"enqueue_writes",level:4},{value:"<code>process_stage() -&gt; bool</code>",id:"process_stage---bool",level:4},{value:"Memory Management",id:"memory-management",level:3},{value:"Transaction Queuing",id:"transaction-queuing",level:4},{value:"Completion Callbacks",id:"completion-callbacks",level:4},{value:"Arch Class",id:"arch-class",level:2},{value:"Overview",id:"overview-2",level:3},{value:"Key Methods",id:"key-methods-2",level:3},{value:"<code>get_cycles() -&gt; RuntimeStats_t*</code>",id:"get_cycles---runtimestats_t",level:4},{value:"Core Scheduling Algorithm",id:"core-scheduling-algorithm",level:3},{value:"Per-Core Job Queues",id:"per-core-job-queues",level:4},{value:"Round-Robin Task Selection",id:"round-robin-task-selection",level:4},{value:"Performance Statistics",id:"performance-statistics",level:3},{value:"Per-Phase Metrics",id:"per-phase-metrics",level:4},{value:"Collection Process",id:"collection-process",level:4},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Creating and Executing Jobs",id:"creating-and-executing-jobs",level:3},{value:"State Machine Implementation",id:"state-machine-implementation",level:3},{value:"See Also",id:"see-also",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"core-classes-api-reference",children:"Core Classes API Reference"})}),"\n",(0,t.jsx)(n.p,{children:"This document describes the core classes that form the backbone of COCOSSim."}),"\n",(0,t.jsx)(n.h2,{id:"job-class",children:"Job Class"}),"\n",(0,t.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Job"})," class represents a single computation task that can be executed by processing units."]}),"\n",(0,t.jsx)(n.h3,{id:"declaration",children:"Declaration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"struct Job {\n  virtual int get_type() const = 0;\n  bool batched_weights = false;\n  uint64_t addr;\n  const uint64_t addr_hold;\n  int task_idx;\n  int job_idx;\n  int core_id = -1;  // Core ID for parallel scheduling (-1 = any core)\n  \n  std::vector<Job *> children;\n  int rem_deps;\n  bool is_done = false;\n  \n  Job(uint64_t alloc_size);\n  virtual std::string get_job_dims_string() const = 0;\n  void printDetails() const;\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-methods",children:"Key Methods"}),"\n",(0,t.jsx)(n.h4,{id:"get_type---int",children:(0,t.jsx)(n.code,{children:"get_type() -> int"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the processing unit type required for this job."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Systolic Array Jobs"}),": Returns systolic array type ID"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Vector Unit Jobs"}),": Returns vector unit type ID"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"get_job_dims_string---string",children:(0,t.jsx)(n.code,{children:"get_job_dims_string() -> string"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns a human-readable string describing the job dimensions.\n",(0,t.jsx)(n.strong,{children:"Example"}),": ",(0,t.jsx)(n.code,{children:'"M=128,K=256,N=512"'})," for matrix multiplication"]}),"\n",(0,t.jsx)(n.h4,{id:"printdetails",children:(0,t.jsx)(n.code,{children:"printDetails()"})}),"\n",(0,t.jsx)(n.p,{children:"Prints comprehensive job information for debugging:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"job->printDetails();\n// Output: Job Type: 0, Dims: M=128,K=256,N=512, Address: 0x1000, Task Index: 5, Remaining Dependencies: 2, Children Count: 3\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-fields",children:"Key Fields"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Field"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"task_idx"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int"})}),(0,t.jsx)(n.td,{children:"Sequential task ID per core for dependency tracking"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"job_idx"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int"})}),(0,t.jsx)(n.td,{children:"Global unique job identifier"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"core_id"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int"})}),(0,t.jsx)(n.td,{children:"Target core for parallel execution (-1 = any core)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"addr"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint64_t"})}),(0,t.jsx)(n.td,{children:"Current memory address for data access"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"addr_hold"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint64_t"})}),(0,t.jsx)(n.td,{children:"Original memory address (preserved during execution)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"children"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"vector<Job*>"})}),(0,t.jsx)(n.td,{children:"Jobs that depend on this job's completion"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"rem_deps"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int"})}),(0,t.jsx)(n.td,{children:"Number of remaining dependencies before execution"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"derived-classes",children:"Derived Classes"}),"\n",(0,t.jsx)(n.h4,{id:"sysarrayjob",children:"SysArrayJob"}),"\n",(0,t.jsx)(n.p,{children:"Matrix multiplication jobs for systolic arrays:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class SysArrayJob : public Job {\n  int M, K, N;  // Matrix dimensions\n  SysArrayJob(int m, int k, int n);\n  string get_job_dims_string() const override;\n};\n"})}),"\n",(0,t.jsx)(n.h4,{id:"vecunitjob",children:"VecUnitJob"}),"\n",(0,t.jsx)(n.p,{children:"Element-wise operations for vector units:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class VecUnitJob : public Job {\n  int linearized_dimension;\n  int parallel_dimension;  \n  queue<pair<VPUPhase, int>> phases;\n  VecUnitJob(int lin_dim, int par_dim, bool batched, vector<pair<VPUPhase, int>> ph);\n};\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"state-class",children:"State Class"}),"\n",(0,t.jsx)(n.h3,{id:"overview-1",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Base class for processing unit state machines, managing memory operations and execution stages."}),"\n",(0,t.jsx)(n.h3,{id:"declaration-1",children:"Declaration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class State {\nprotected:\n  int state = 0;\n  int min_stage_cycles = 0;\n  int mem_read_left = 0, mem_write_left = 0;\n  int mem_read_left_unqueued = 0, mem_write_left_unqueued = 0;\n  int mem_queued = 0;\n  bool is_idle_from_memory = false;\n  \npublic:\n  Job *j = nullptr;\n  int vcd_idx;\n  int core_memory_priority;\n  \n  virtual bool increment(const function<void(Job *)> &enqueue_job, int &total_idle, int *n_idle_units) = 0;\n  virtual void init() = 0;\n  virtual int get_ty_idx() const = 0;\n  virtual string get_ty_string() const = 0;\n  \nprotected:\n  void enqueue_reads();\n  void enqueue_writes();  \n  bool process_stage();\n  void check_idle_from_memory();\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-methods-1",children:"Key Methods"}),"\n",(0,t.jsx)(n.h4,{id:"increment---bool",children:(0,t.jsx)(n.code,{children:"increment() -> bool"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Execute one simulation cycle\n",(0,t.jsx)(n.strong,{children:"Returns"}),": ",(0,t.jsx)(n.code,{children:"true"})," if unit is active (consuming power)\n",(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"enqueue_job"}),": Function to enqueue dependent jobs upon completion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"total_idle"}),": Reference to global idle unit counter"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"n_idle_units"}),": Array of idle units per type"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation Pattern"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"bool MyState::increment(const function<void(Job *)> &enqueue_job, int &total_idle, int *n_idle_units) {\n    enqueue_reads();   // Queue memory reads\n    enqueue_writes();  // Queue memory writes\n    \n    if (process_stage()) {\n        // State machine logic here\n        switch (state) {\n            case STATE_A: /* transition logic */ break;\n            case STATE_B: /* transition logic */ break;\n        }\n    }\n    \n    return is_active;  // Return true if consuming power\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"init",children:(0,t.jsx)(n.code,{children:"init()"})}),"\n",(0,t.jsx)(n.p,{children:"Initialize the processing unit with a new job:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void init() override {\n    // Reset state machine\n    state = initial_state;\n    min_stage_cycles = 0;\n    \n    // Setup memory operations\n    mem_read_left = calculate_reads();\n    mem_write_left = calculate_writes();\n    \n    // Initialize unit-specific parameters\n    setup_execution_parameters();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"protected-methods",children:"Protected Methods"}),"\n",(0,t.jsx)(n.h4,{id:"enqueue_reads",children:(0,t.jsx)(n.code,{children:"enqueue_reads()"})}),"\n",(0,t.jsx)(n.p,{children:"Queue memory read transactions with bandwidth limits:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void State::enqueue_reads() {\n    if (mem_read_left_unqueued > 0) {\n        int to_enq = min(dram_enq_per_cycle, mem_read_left_unqueued);\n        mem_read_left_unqueued -= to_enq;\n        mem_queued += to_enq;\n        for (int i = 0; i < to_enq; ++i) {\n            to_enqueue.emplace_back(j->addr, false, core_memory_priority, this);\n            j->addr += bytes_per_tx;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"enqueue_writes",children:(0,t.jsx)(n.code,{children:"enqueue_writes()"})}),"\n",(0,t.jsxs)(n.p,{children:["Queue memory write transactions with bandwidth limits (similar to reads but with ",(0,t.jsx)(n.code,{children:"is_write = true"}),")."]}),"\n",(0,t.jsx)(n.h4,{id:"process_stage---bool",children:(0,t.jsx)(n.code,{children:"process_stage() -> bool"})}),"\n",(0,t.jsx)(n.p,{children:"Process current execution stage:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"bool State::process_stage() {\n    if (min_stage_cycles > 0) min_stage_cycles--;\n    \n    if (min_stage_cycles == 0 && mem_read_left == 0 && mem_write_left == 0) {\n        return true;  // Stage complete, ready for state transition\n    }\n    \n    check_idle_from_memory();\n    return false;  // Stage still in progress\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(n.h4,{id:"transaction-queuing",children:"Transaction Queuing"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bandwidth Limited"}),": Respects ",(0,t.jsx)(n.code,{children:"dram_enq_per_cycle"})," limit"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Priority Based"}),": Uses ",(0,t.jsx)(n.code,{children:"core_memory_priority"})," for scheduling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Address Tracking"}),": Automatically increments addresses"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"completion-callbacks",children:"Completion Callbacks"}),"\n",(0,t.jsx)(n.p,{children:"Memory operations complete asynchronously via callbacks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Read completion decrements mem_read_left\n// Write completion decrements mem_write_left\n// When both reach 0, stage can complete\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"arch-class",children:"Arch Class"}),"\n",(0,t.jsx)(n.h3,{id:"overview-2",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Main architecture class that coordinates the entire simulation, managing processing units and the global simulation loop."}),"\n",(0,t.jsx)(n.h3,{id:"key-methods-2",children:"Key Methods"}),"\n",(0,t.jsx)(n.h4,{id:"get_cycles---runtimestats_t",children:(0,t.jsx)(n.code,{children:"get_cycles() -> RuntimeStats_t*"})}),"\n",(0,t.jsx)(n.p,{children:"Execute the main simulation loop:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"RuntimeStats_t *get_cycles(TimeBasedEnqueue &time_enqueues) {\n    // Setup phase-based execution\n    // Initialize per-core job queues  \n    // Main simulation loop:\n    //   - Process job scheduling\n    //   - Update processing units\n    //   - Handle memory transactions\n    //   - Collect statistics\n    // Return performance metrics\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"core-scheduling-algorithm",children:"Core Scheduling Algorithm"}),"\n",(0,t.jsx)(n.h4,{id:"per-core-job-queues",children:"Per-Core Job Queues"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Each task thread has independent job queues per processing unit type\nmap<int, vector<Job *> *> task_frontiers;\nfor (int i = 0; i < alloc_task_idx; ++i) {\n    task_frontiers[i] = new vector<Job *>[n_types];\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"round-robin-task-selection",children:"Round-Robin Task Selection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"for (int i = 0; i < n_types && !enqueued_job; ++i) {\n    auto &fr = frontier[i];\n    if (fr->empty()) {\n        task_ids[i] = (task_ids[i] + 1) % n_threads;  // Round-robin\n        fr = &(task_frontiers[task_ids[i]][i]);\n    }\n    \n    if (!fr->empty() && n_idle_units[i] > 0) {\n        // Assign job to available processing unit\n        Job *job = fr->front();\n        State *state = have_idle_type(i);\n        // ... assignment logic\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"performance-statistics",children:"Performance Statistics"}),"\n",(0,t.jsx)(n.h4,{id:"per-phase-metrics",children:"Per-Phase Metrics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"struct RuntimeStats_t {\n    uint64_t cycles;\n    double *pct_active;  // Per-unit utilization percentages\n};\n"})}),"\n",(0,t.jsx)(n.h4,{id:"collection-process",children:"Collection Process"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Per-Cycle"}),": Track active units"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Per-Phase"}),": Calculate utilization statistics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory"}),": Monitor DRAM command counts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Utilization"}),": Percentage active time per processing unit"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.h3,{id:"creating-and-executing-jobs",children:"Creating and Executing Jobs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Create a matrix multiplication job\nauto job = new SystolicArray::SysArrayJob(128, 256, 512);  // M, K, N\njob->core_id = 0;  // Assign to core 0\njob->task_idx = 5; // Task sequence number\n\n// Create dependencies\nJob *dependent_job = new SystolicArray::SysArrayJob(512, 256, 128);\njob->children.push_back(dependent_job);\ndependent_job->rem_deps = 1;\n\n// Execute simulation\nTimeBasedEnqueue enqueue;\nenqueue.enqueue_at(0, {job});\nauto stats = arch->get_cycles(enqueue);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"state-machine-implementation",children:"State Machine Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class MyProcessingUnit : public State {\n    enum MyStates { IDLE, COMPUTE, WRITEBACK };\n    \n    bool increment(const function<void(Job *)> &enqueue_job, int &total_idle, int *n_idle_units) override {\n        enqueue_reads();\n        enqueue_writes();\n        \n        if (process_stage()) {\n            switch (state) {\n                case IDLE: break;  // Wait for job assignment\n                case COMPUTE:\n                    if (computation_done()) {\n                        state_transfer(WRITEBACK, 0, output_size, 0);\n                    }\n                    break;\n                case WRITEBACK:\n                    // Job complete, enqueue dependent jobs\n                    for (auto *child : j->children) {\n                        if (--child->rem_deps == 0) {\n                            enqueue_job(child);\n                        }\n                    }\n                    state_transfer(IDLE, 0, 0, 0);\n                    break;\n            }\n        }\n        \n        return state != IDLE;  // Active if not idle\n    }\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/cocossim-docs/docs/guides/architecture",children:"Architecture Guide"})," - High-level system design"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/cocossim-docs/docs/guides/basic-usage",children:"Basic Usage Guide"})," - Getting started with simulations"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function c(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);